#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2014 Colin Walters <walters@redhat.com>
# Forked from:
# guest-image-ovf-creator.py - Copyright (C) 2013 Red Hat, Inc.
# Written by Joey Boggs <jboggs@redhat.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA  02110-1301, USA.  A copy of the GNU General Public License is
# also available at http://www.gnu.org/copyleft/gpl.html.

import json
import os
import sys
import struct
import uuid
import tempfile
import logging
import hashlib
import time
import argparse
import shutil
import subprocess
import distutils.spawn
from gi.repository import Gio, OSTree, GLib
import iniparse

from .taskbase import TaskBase
from .utils import run_sync, fail_msg

OVF_VERSION = "3.3.0.0"

OVF_TEMPLATE = """
<?xml version="1.0" encoding="UTF-8"?>
<!-- Generated by cloud2ovf.py from github.com/projectatomic/rpm-ostree-toolbox -->
<ovf:Envelope xmlns:ovf="http://schemas.dmtf.org/ovf/envelope/1/" \
xmlns:rasd="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/\
CIM_ResourceAllocationSettingData" xmlns:vssd="http://schemas.dmtf.org/wbem\
/wscim/1/cim-schema/2/CIM_VirtualSystemSettingData" xmlns:xsi=\
"http://www.w3.org/2001/XMLSchema-instance" ovf:version="%(ovf_version)s">
  <References>
    <File ovf:description="%(product_name)s" ovf:href="%(disk_file_name)s"\
 ovf:id="%(disk_file_name)s" ovf:size="%(raw_disk_size)s"/>
  </References>
  <Section xsi:type="ovf:NetworkSection_Type">
    <Info>List of Networks</Info>
  </Section>
  <Section xsi:type="ovf:DiskSection_Type">
    <Disk ovf:actual_size="%(disk_size_gb)s" ovf:boot="true"\
 ovf:disk-interface="VirtIO" ovf:disk-type="System"\
 ovf:diskId="%(disk_file_name)s" ovf:fileRef="%(disk_file_name)s"\
 ovf:format="http://www.vmware.com/specifications/vmdk.html#sparse"\
 ovf:parentRef="" ovf:size="%(disk_size_gb)s"\
 ovf:vm_snapshot_id="%(snapshot_id)s"\
 ovf:volume-format="COW" ovf:volume-type="Sparse"\
 ovf:wipe-after-delete="false"/>
  </Section>
  <Content ovf:id="out" xsi:type="ovf:VirtualSystem_Type">
    <Name>%(product_name)s</Name>
    <TemplateId>%(product_name)s</TemplateId>
    <Description>%(product_name)s</Description>
    <Domain/>
    <CreationDate>%(timestamp)s</CreationDate>
    <TimeZone/>
    <IsAutoSuspend>false</IsAutoSuspend>
    <VmType>1</VmType>
    <default_display_type>1</default_display_type>
    <default_boot_sequence>1</default_boot_sequence>
    <Section ovf:id="f9350d95-31b7-41d4-87ac-1526fa1435ab" \
ovf:required="false" xsi:type="ovf:OperatingSystemSection_Type">
      <Info>Guest OS</Info>
      <Description>rhel_7x64</Description>
    </Section>
    <Section xsi:type="ovf:VirtualHardwareSection_Type">
      <Info>1 CPU, 512 Memory</Info>
      <System>
        <vssd:VirtualSystemType>RHEVM 4.6.0.163</vssd:VirtualSystemType>
      </System>
      <Item>
        <rasd:Caption>1 virtual CPU</rasd:Caption>
        <rasd:Description>Number of virtual CPU</rasd:Description>
        <rasd:InstanceId>1</rasd:InstanceId>
        <rasd:ResourceType>3</rasd:ResourceType>
        <rasd:num_of_sockets>1</rasd:num_of_sockets>
        <rasd:cpu_per_socket>1</rasd:cpu_per_socket>
      </Item>
      <Item>
        <rasd:Caption>512 MB of memory</rasd:Caption>
        <rasd:Description>Memory Size</rasd:Description>
        <rasd:InstanceId>2</rasd:InstanceId>
        <rasd:ResourceType>4</rasd:ResourceType>
        <rasd:AllocationUnits>MegaBytes</rasd:AllocationUnits>
        <rasd:VirtualQuantity>512</rasd:VirtualQuantity>
      </Item>
      <Item>
        <rasd:Caption>Drive 1</rasd:Caption>
        <rasd:InstanceId>%(disk_file_name)s</rasd:InstanceId>
        <rasd:ResourceType>17</rasd:ResourceType>
        <rasd:HostResource>%(disk_file_name)s</rasd:HostResource>
        <rasd:Parent>00000000-0000-0000-0000-000000000000</rasd:Parent>
        <rasd:Template>00000000-0000-0000-0000-000000000000</rasd:Template>
        <rasd:ApplicationList/>
        <rasd:StorageId>00000000-0000-0000-0000-000000000000</rasd:StorageId>
        <rasd:StoragePoolId>%(storage_pool_id)s</rasd:StoragePoolId>
        <rasd:CreationDate>%(timestamp)s</rasd:CreationDate>
        <rasd:LastModified>%(timestamp)s</rasd:LastModified>
      </Item>
      <Item>
        <rasd:Caption>Ethernet 0 rhevm</rasd:Caption>
        <rasd:InstanceId>3</rasd:InstanceId>
        <rasd:ResourceType>10</rasd:ResourceType>
        <rasd:ResourceSubType>3</rasd:ResourceSubType>
        <rasd:Connection>rhevm</rasd:Connection>
        <rasd:Name>eth0</rasd:Name>
        <rasd:speed>1000</rasd:speed>
      </Item>
      <Item>
        <rasd:Caption>Graphics</rasd:Caption>
        <rasd:InstanceId>5</rasd:InstanceId>
        <rasd:ResourceType>20</rasd:ResourceType>
        <rasd:VirtualQuantity>1</rasd:VirtualQuantity>
      </Item>
    </Section>
  </Content>
</ovf:Envelope>
"""

class Cloud2OVF(object):
    def __init__(self, input_disk, output_ova, tmp_dir):
        self._input_disk = input_disk
        self._output = output_ova
        self._tmp_dir = tmp_dir
        
        if os.path.exists(output_ova):
            raise RuntimeError("Output path '" + output_ova + "' exists")

        self._image_basename = os.path.basename(os.path.splitext(input_disk)[0])
        self._image_name = self._image_basename + '.vmdk'
        logging.info("Image Name: %s" % self._image_basename)
        self._raw_create_time = time.time()
        self._create_time = time.gmtime(self._raw_create_time)
        self._ovf_template_dest = os.path.join(self._tmp_dir,
                                               self._image_basename + ".ovf")
        self._mf_dest = os.path.join(self._tmp_dir,
                                     self._image_basename + ".mf")
        self._disk_dest = os.path.join(self._tmp_dir, self._image_name)
        logging.info("OVF Template: %s" % self._ovf_template_dest)
        logging.info("Disk Destination: %s" % self._disk_dest)

    def _get_qcow_size(self):
        qcow_struct = ">IIQIIQIIQQIIQ"  # > means big-endian
        qcow_magic = 0x514649FB  # 'Q' 'F' 'I' 0xFB
        f = open(self._input_disk, "r")
        pack = f.read(struct.calcsize(qcow_struct))
        f.close()
        unpack = struct.unpack(qcow_struct, pack)
        if unpack[0] == qcow_magic:
            size = unpack[5]
        return size

    def _write_ovf_template(self, input_size):
        disk_size = self._get_qcow_size()
        ovf_dict = {"product_name": self._image_name,
                    "ovf_version": OVF_VERSION,
                    "disk_file_name": self._image_name,
                    "snapshot_id": str(uuid.uuid4()),
                    "storage_pool_id": str(uuid.uuid4()),
                    "raw_disk_size": input_size,
                    "disk_size_gb": input_size / (1024 * 1024 * 1024),
                    "timestamp": time.strftime("%Y/%m/%d %H:%M:%S",
                                               self._create_time)
                    }
        logging.info("Writing OVF Template")
        with open(self._ovf_template_dest, "w") as f:
            f.write(OVF_TEMPLATE % ovf_dict)

    def _generate_mf(self):
        with open(self._mf_dest, 'w') as f:
            for path in [self._ovf_template_dest,
                         self._disk_dest]:
                bn = os.path.basename(path)
                s = hashlib.sha1()
                with open(path) as infile:
                    buf = infile.read(8192)
                    while buf != '':
                        s.update(buf)
                        buf = infile.read(8192)
                f.write('SHA1(%s) = %s\n'  % (bn, s.hexdigest()))

    def run(self):
        input_size = self._get_qcow_size() / 512
        run_sync(['qemu-img', 'convert', '-O', 'vmdk', '-f', 'qcow2', self._input_disk, self._disk_dest])
        self._write_ovf_template(input_size=input_size)
        self._generate_mf()
        run_sync(['tar', '-C', self._tmp_dir, '-c', '-f', self._output,
                  os.path.basename(self._ovf_template_dest),
                  os.path.basename(self._disk_dest),
                  os.path.basename(self._mf_dest)])

def main():
    logging.basicConfig()

    parser = argparse.ArgumentParser(description='Turn a qcow2 disk image into an OVA file')
    parser.add_argument('-i', '--input', type=str, required=True, help="Input qcow2")
    parser.add_argument('-o', '--output', type=str, required=True, help="Output destination")
    args = parser.parse_args()

    tmp_dir = tempfile.mkdtemp('cloud2ovf')
    try:
        task = Cloud2OVF(args.input, args.output, tmp_dir)
        task.run()
    finally:
        shutil.rmtree(tmp_dir)
